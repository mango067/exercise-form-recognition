# exercise_detector_full.py
import cv2
import mediapipe as mp
import math
import time

# -------------------------
# Geometry helpers
# -------------------------
def distance(a, b):
    return math.hypot(a[0]-b[0], a[1]-b[1])

def midpoint(a, b):
    return ((a[0]+b[0])//2, (a[1]+b[1])//2)

def calculate_angle(a, b, c):
    # angle ABC
    ax, ay = a; bx, by = b; cx, cy = c
    ab = (ax - bx, ay - by)
    cb = (cx - bx, cy - by)
    mag_ab = math.hypot(ab[0], ab[1])
    mag_cb = math.hypot(cb[0], cb[1])
    if mag_ab * mag_cb == 0:
        return None
    dot = ab[0]*cb[0] + ab[1]*cb[1]
    cosv = max(-1.0, min(1.0, dot/(mag_ab*mag_cb)))
    return math.degrees(math.acos(cosv))

def vector(a, b):
    return (b[0]-a[0], b[1]-a[1])

def angle_between(vec1, vec2):
    ax, ay = vec1; bx, by = vec2
    mag_a = math.hypot(ax, ay); mag_b = math.hypot(bx, by)
    if mag_a*mag_b == 0:
        return None
    dot = ax*bx + ay*by
    cosv = max(-1.0, min(1.0, dot/(mag_a*mag_b)))
    return math.degrees(math.acos(cosv))

# -------------------------
# Mediapipe init + indices
# -------------------------
mp_drawing = mp.solutions.drawing_utils
mp_pose = mp.solutions.pose

joint_indices = {
    1: mp_pose.PoseLandmark.RIGHT_SHOULDER,
    2: mp_pose.PoseLandmark.LEFT_SHOULDER,
    3: mp_pose.PoseLandmark.RIGHT_ELBOW,
    4: mp_pose.PoseLandmark.LEFT_ELBOW,
    5: mp_pose.PoseLandmark.RIGHT_WRIST,
    6: mp_pose.PoseLandmark.LEFT_WRIST,
    7: mp_pose.PoseLandmark.RIGHT_HIP,
    8: mp_pose.PoseLandmark.LEFT_HIP,
    9: mp_pose.PoseLandmark.RIGHT_KNEE,
    10: mp_pose.PoseLandmark.LEFT_KNEE,
    11: mp_pose.PoseLandmark.RIGHT_ANKLE,
    12: mp_pose.PoseLandmark.LEFT_ANKLE,
    13: mp_pose.PoseLandmark.RIGHT_HEEL,
    14: mp_pose.PoseLandmark.LEFT_HEEL,
    15: mp_pose.PoseLandmark.RIGHT_FOOT_INDEX,
    16: mp_pose.PoseLandmark.LEFT_FOOT_INDEX
}
connections = [
    (1,2),(1,3),(3,5),(2,4),(4,6),
    (1,7),(2,8),(7,8),
    (7,9),(9,11),(11,13),(13,15),
    (8,10),(10,12),(12,14),(14,16)
]

# -------------------------
# Parameters & thresholds
# -------------------------
ASSUMED_PERSON_HEIGHT_INCHES = 65.0

# Lunge rules
LUNGE_FRONT_MIN = 80   # front knee at bottom minimal flex
LUNGE_FRONT_MAX = 110  # front knee at bottom maximal flex
LUNGE_BACK_MAX = 40    # back knee flex <=40 deg considered approx 20 deg ideal
# Squat rules
SQUAT_KNEE_MIN = 80
SQUAT_KNEE_MAX = 100
SQUAT_BACK_MIN_ANGLE = 160  # shoulder-hip angle >=160 means back straight
SQUAT_HIP_DROP_FRAC = 0.25  # hips must drop at least 25% of body height
# Push-up rules
PUSHUP_BODY_MIN = 160
PUSHUP_BODY_MAX = 190
PUSHUP_ELBOW_BOTTOM_MAX = 140  # elbow angle at bottom <=140 deg
PUSHUP_CHEST_MIN_IN = 2.0
PUSHUP_CHEST_MAX_IN = 19.2  # 1.6 ft = 19.2 inches
# generic
VIS_THRESHOLD = 0.35

# -------------------------
# Helpers converting mediapipe landmarks
# -------------------------
def landmarks_to_joints(landmarks, w, h):
    joints = {}
    for i, lm_enum in joint_indices.items():
        lm = landmarks[lm_enum.value]
        joints[i] = (int(lm.x*w), int(lm.y*h), lm.visibility)
    # also add nose for facing detection and chest approx using midpoint shoulders
    nose_lm = landmarks[mp_pose.PoseLandmark.NOSE.value]
    joints['nose'] = (int(nose_lm.x*w), int(nose_lm.y*h), nose_lm.visibility)
    return joints

def estimate_body_height_px(joints):
    if 1 in joints and 2 in joints and 11 in joints and 12 in joints:
        shoulder_mid = midpoint(joints[1][:2], joints[2][:2])
        ankle_mid = midpoint(joints[11][:2], joints[12][:2])
        return distance(shoulder_mid, ankle_mid)
    return None

def estimate_ground_y(joints):
    cands = []
    for idx in (11,12,13,14):
        if idx in joints and joints[idx][2] > VIS_THRESHOLD:
            cands.append(joints[idx][1])
    if cands:
        return max(cands)
    return None

# -------------------------
# Facing detection (up/down) used for push-up vs others
# -------------------------
def detect_facing(joints):
    # uses nose and shoulders: if nose y > avg shoulder y => facing down
    if 'nose' not in joints or 1 not in joints or 2 not in joints:
        return 'unknown'
    nose_y = joints['nose'][1]; vis_n = joints['nose'][2]
    if vis_n < VIS_THRESHOLD: return 'unknown'
    sh_y = (joints[1][1] + joints[2][1]) / 2
    if nose_y > sh_y:
        return 'down'
    else:
        return 'up'

# -------------------------
# Exercise classification
# -------------------------
def classify_exercise(joints, h_px):
    # produce simple classification based on posture and key angles
    # Compute some angles if available
    def get(idx): return joints[idx][:2] if idx in joints else None
    shoulder_mid = None
    if 1 in joints and 2 in joints:
        shoulder_mid = midpoint(joints[1][:2], joints[2][:2])
    hip_mid = None
    if 7 in joints and 8 in joints:
        hip_mid = midpoint(joints[7][:2], joints[8][:2])

    # compute key angles
    # body (shoulder-hip-knee) using right side fallback left
    def choose_coords(r,l):
        if r in joints and joints[r][2] > VIS_THRESHOLD: return joints[r][:2]
        if l in joints and joints[l][2] > VIS_THRESHOLD: return joints[l][:2]
        return None

    shoulder = choose_coords(1,2)
    hip = choose_coords(7,8)
    knee = choose_coords(9,10)
    ankle = choose_coords(11,12)
    elbow_r = joints[3][:2] if 3 in joints and joints[3][2] > VIS_THRESHOLD else None
    elbow_l = joints[4][:2] if 4 in joints and joints[4][2] > VIS_THRESHOLD else None

    # angles
    hip_angle = calculate_angle(shoulder, hip, knee) if shoulder and hip and knee else None
    knee_r = calculate_angle(joints[7][:2], joints[9][:2], joints[11][:2]) if 7 in joints and 9 in joints and 11 in joints else None
    knee_l = calculate_angle(joints[8][:2], joints[10][:2], joints[12][:2]) if 8 in joints and 10 in joints and 12 in joints else None
    shoulder_hip_angle = calculate_angle(joints[3][:2], joints[1][:2], joints[7][:2]) if 3 in joints and 1 in joints and 7 in joints else None

    # detect push-up posture (body near horizontal and facing down)
    # we check if shoulders and hips are roughly at same vertical level (difference small)
    is_horizontal_body = False
    if shoulder and hip and abs(shoulder[1] - hip[1]) < 60:
        is_horizontal_body = True

    facing = detect_facing(joints)
    # heuristics
    if facing == 'down' and is_horizontal_body:
        return 'pushup'
    # squat/lunge: upright torso
    if shoulder and hip and shoulder[1] < hip[1] - 50:
        # upright torso: check knees: if both knees bent ~ then squat; if one knee bent and other straight => lunge
        if knee_r and knee_l:
            # lunge if one knee flex << the other
            if (knee_r < 110 and knee_l > 150) or (knee_l < 110 and knee_r > 150):
                return 'lunge'
            # squat if both knees moderate flex (< 120)
            if (knee_r < 120 and knee_l < 120):
                return 'squat'
    return 'unknown'

# -------------------------
# Form checks per exercise (as requested)
# -------------------------
def check_lunge_form(joints, body_h_px):
    # need front/back identification: one knee much more bent than other -> front is bent
    res = {'ok': False, 'reasons': []}
    if 9 not in joints or 10 not in joints or 7 not in joints or 8 not in joints:
        res['reasons'].append('Not enough joints')
        return res
    knee_r = calculate_angle(joints[7][:2], joints[9][:2], joints[11][:2]) if 7 in joints and 9 in joints and 11 in joints else None
    knee_l = calculate_angle(joints[8][:2], joints[10][:2], joints[12][:2]) if 8 in joints and 10 in joints and 12 in joints else None
    if knee_r is None or knee_l is None:
        res['reasons'].append('Knee angles not detected')
        return res
    # determine front = more bent (smaller angle)
    if knee_r < knee_l:
        front_knee = knee_r; back_knee = knee_l
    else:
        front_knee = knee_l; back_knee = knee_r

    # checks: front between 80 and 110; back <=40 (accept <=40); torso upright; both feet visible
    if not (LUNGE_FRONT_MIN <= front_knee <= LUNGE_FRONT_MAX):
        res['reasons'].append(f'Front knee at {front_knee:.1f}° (need {LUNGE_FRONT_MIN}-{LUNGE_FRONT_MAX})')
    if not (back_knee <= LUNGE_BACK_MAX):
        res['reasons'].append(f'Back knee at {back_knee:.1f}° (should be ≤{LUNGE_BACK_MAX})')
    # torso upright: shoulders above hips (shoulder_y < hip_y)
    if 1 in joints and 2 in joints and 7 in joints and 8 in joints:
        shoulder_mid = midpoint(joints[1][:2], joints[2][:2])
        hip_mid = midpoint(joints[7][:2], joints[8][:2])
        if not (shoulder_mid[1] < hip_mid[1] + 20):  # allow slight tilt
            res['reasons'].append('Torso not upright')
    else:
        res['reasons'].append('Cannot verify torso')
    # both feet visible (simple check)
    if not ((11 in joints and joints[11][2] > VIS_THRESHOLD) and (12 in joints and joints[12][2] > VIS_THRESHOLD)):
        res['reasons'].append('Both feet not visible')

    res['ok'] = (len(res['reasons']) == 0)
    return res

def check_squat_form(joints, body_h_px):
    res = {'ok': False, 'reasons': []}
    # need knees and hips
    if not all(idx in joints for idx in (7,8,9,10,11,12,1,2)):
        res['reasons'].append('Not enough joints')
        return res
    knee_r = calculate_angle(joints[7][:2], joints[9][:2], joints[11][:2])
    knee_l = calculate_angle(joints[8][:2], joints[10][:2], joints[12][:2])
    shoulder_hip_angle_r = calculate_angle(joints[3][:2], joints[1][:2], joints[7][:2]) if 3 in joints else None
    # hip drop: compare hip y vs shoulder y initial vs current: ensure hip is lowered at least 25% body height
    shoulder_mid = midpoint(joints[1][:2], joints[2][:2])
    hip_mid = midpoint(joints[7][:2], joints[8][:2])
    hip_drop = (hip_mid[1] - shoulder_mid[1])  # px, positive when hip below shoulder
    hip_drop_ok = False
    if body_h_px:
        hip_drop_ok = hip_drop >= SQUAT_HIP_DROP_FRAC * body_h_px
    # knees in allowed range
    knee_ok = (knee_r is not None and SQUAT_KNEE_MIN <= knee_r <= SQUAT_KNEE_MAX) and \
              (knee_l is not None and SQUAT_KNEE_MIN <= knee_l <= SQUAT_KNEE_MAX)
    if not knee_ok:
        res['reasons'].append(f'Knees angles {knee_r:.1f}/{knee_l:.1f} not in {SQUAT_KNEE_MIN}-{SQUAT_KNEE_MAX}')
    # back straight
    back_ok = shoulder_hip_angle_r is not None and shoulder_hip_angle_r >= SQUAT_BACK_MIN_ANGLE
    if not back_ok:
        res['reasons'].append('Back not straight')
    if not hip_drop_ok:
        res['reasons'].append('Hips did not drop enough')
    # knees track over toes: simple check comparing knee x vs ankle x
    toes_ok = True
    for k_idx, a_idx in ((9,11),(10,12)):
        if k_idx in joints and a_idx in joints:
            kx = joints[k_idx][0]; ax = joints[a_idx][0]
            if abs(kx - ax) > 80:  # tolerant threshold (pixels)
                toes_ok = False
    if not toes_ok:
        res['reasons'].append('Knees may not track over toes')
    res['ok'] = (len(res['reasons']) == 0)
    return res

def check_pushup_form(joints, body_h_px):
    res = {'ok': False, 'reasons': []}
    # need shoulders, hips, knees, elbows, chest (approx)
    if not all(idx in joints for idx in (1,2,7,8,9,10,11,12)):
        res['reasons'].append('Not enough joints')
        return res
    # body straight: hip angle (shoulder-hip-knee)
    shoulder = midpoint(joints[1][:2], joints[2][:2])
    hip = midpoint(joints[7][:2], joints[8][:2])
    knee = midpoint(joints[9][:2], joints[10][:2]) if 9 in joints and 10 in joints else None
    # prefer compute hip angle using right side if visible
    right_side_ok = (1 in joints and 7 in joints and 9 in joints)
    left_side_ok = (2 in joints and 8 in joints and 10 in joints)
    hip_angle = None
    if right_side_ok:
        hip_angle = calculate_angle(joints[1][:2], joints[7][:2], joints[9][:2])
    elif left_side_ok:
        hip_angle = calculate_angle(joints[2][:2], joints[8][:2], joints[10][:2])
    if hip_angle is None or not (PUSHUP_BODY_MIN <= hip_angle <= PUSHUP_BODY_MAX):
        res['reasons'].append(f'Body not straight (hip angle {hip_angle})')
    # elbow bottom: find elbow angle (use whichever visible side)
    elbow_angle_r = calculate_angle(joints[1][:2], joints[3][:2], joints[5][:2]) if 1 in joints and 3 in joints and 5 in joints else None
    elbow_angle_l = calculate_angle(joints[2][:2], joints[4][:2], joints[6][:2]) if 2 in joints and 4 in joints and 6 in joints else None
    elbow_bottom_ok = False
    if elbow_angle_r is not None and elbow_angle_r <= PUSHUP_ELBOW_BOTTOM_MAX:
        elbow_bottom_ok = True
    if elbow_angle_l is not None and elbow_angle_l <= PUSHUP_ELBOW_BOTTOM_MAX:
        elbow_bottom_ok = True
    if not elbow_bottom_ok:
        res['reasons'].append('Elbows did not bend enough at bottom')
    # chest to ground: estimate ground and chest y (chest approx = midpoint shoulders -> hips)
    ground_y = estimate_ground_y(joints)
    if ground_y is None:
        res['reasons'].append('Cannot estimate ground')
    else:
        chest_y = (shoulder[1] + hip[1]) / 2
        height_px = ground_y - chest_y
        pixels_per_inch = body_h_px / ASSUMED_PERSON_HEIGHT_INCHES if body_h_px else 10.0
        chest_in = height_px / pixels_per_inch
        if not (PUSHUP_CHEST_MIN_IN <= chest_in <= PUSHUP_CHEST_MAX_IN):
            res['reasons'].append(f'Chest height {chest_in:.1f}" not in {PUSHUP_CHEST_MIN_IN}-{PUSHUP_CHEST_MAX_IN}')
    # hips sag/pike: check hip-shoulder-knee angle roughly
    # if hip angle too low (<160) we flagged earlier
    # finalize
    res['ok'] = (len(res['reasons']) == 0)
    return res

# -------------------------
# Repetition counters: simple state machines per exercise
# -------------------------
class RepCounter:
    def __init__(self):
        self.count = 0
        self.state = 'up'  # generic state: 'up' or 'down'
        self.last_transition_time = time.time()

    def update(self, is_down):
        # is_down = True when at the bottom position for that exercise
        # count a rep when down -> up transition completes
        now = time.time()
        if self.state == 'up' and is_down:
            self.state = 'down'
            self.last_transition_time = now
        elif self.state == 'down' and not is_down:
            # completed rep
            self.count += 1
            self.state = 'up'
            self.last_transition_time = now

# instantiate counters
counters = {'pushup': RepCounter(), 'squat': RepCounter(), 'lunge': RepCounter()}

# -------------------------
# Main loop
# -------------------------
cap = cv2.VideoCapture(0)
with mp_pose.Pose(min_detection_confidence=0.5, min_tracking_confidence=0.5) as pose:
    while True:
        ret, frame = cap.read()
        if not ret:
            break
        key = cv2.waitKey(1) & 0xFF
        if key == ord('q'):
            break

        h, w = frame.shape[:2]
        img_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = pose.process(img_rgb)
        img = frame.copy()

        if results.pose_landmarks:
            joints = landmarks_to_joints(results.pose_landmarks.landmark, w, h)
            body_h_px = estimate_body_height_px(joints) or (h * 0.6)
            # draw joints + skeleton
            for idx, val in joints.items():
                if isinstance(idx, int):
                    x,y,vis = val
                    if vis > VIS_THRESHOLD:
                        cv2.circle(img, (x,y), 4, (0,0,255), -1)
                        cv2.putText(img, str(idx), (x+5,y-5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255,255,255),1)
            for a,b in connections:
                if a in joints and b in joints and joints[a][2] > VIS_THRESHOLD and joints[b][2] > VIS_THRESHOLD:
                    cv2.line(img, joints[a][:2], joints[b][:2], (0,255,0), 2)

            # classify exercise
            exercise = classify_exercise(joints, body_h_px)
            feedback = ''
            ok = False
            # For counting we need to decide bottom (is_down) heuristics per exercise
            is_down = False

            if exercise == 'pushup':
                check = check_pushup_form(joints, body_h_px)
                ok = check['ok']
                feedback = "Push-Up: " + ("Good" if ok else "Bad: " + "; ".join(check['reasons']))
                # determine bottom: elbow angle small and chest low
                # compute elbow angles
                elbow_r = calculate_angle(joints[1][:2], joints[3][:2], joints[5][:2]) if 1 in joints and 3 in joints and 5 in joints else None
                elbow_l = calculate_angle(joints[2][:2], joints[4][:2], joints[6][:2]) if 2 in joints and 4 in joints and 6 in joints else None
                elbow_min = min([v for v in (elbow_r, elbow_l) if v is not None], default=180)
                # chest height
                ground_y = estimate_ground_y(joints) or (h*0.98)
                shoulder_mid = midpoint(joints[1][:2], joints[2][:2])
                hip_mid = midpoint(joints[7][:2], joints[8][:2])
                chest_y = (shoulder_mid[1] + hip_mid[1]) / 2
                pixels_per_inch = body_h_px / ASSUMED_PERSON_HEIGHT_INCHES
                chest_in = (ground_y - chest_y) / pixels_per_inch if pixels_per_inch>0 else 0
                # define bottom if elbow angle <= PUSHUP_ELBOW_BOTTOM_MAX or chest within threshold
                is_down = (elbow_min <= PUSHUP_ELBOW_BOTTOM_MAX) or (chest_in <= 6.0)  # bottom
                counters['pushup'].update(is_down)

            elif exercise == 'squat':
                check = check_squat_form(joints, body_h_px)
                ok = check['ok']
                feedback = "Squat: " + ("Good" if ok else "Bad: " + "; ".join(check['reasons']))
                # bottom if knee average angle <= SQUAT_KNEE_MAX
                knee_r = calculate_angle(joints[7][:2], joints[9][:2], joints[11][:2]) if 7 in joints and 9 in joints and 11 in joints else None
                knee_l = calculate_angle(joints[8][:2], joints[10][:2], joints[12][:2]) if 8 in joints and 10 in joints and 12 in joints else None
                knee_avg = None
                vals = [v for v in (knee_r, knee_l) if v is not None]
                if vals:
                    knee_avg = sum(vals)/len(vals)
                if knee_avg is not None:
                    is_down = knee_avg <= SQUAT_KNEE_MAX
                    counters['squat'].update(is_down)

            elif exercise == 'lunge':
                check = check_lunge_form(joints, body_h_px)
                ok = check['ok']
                feedback = "Lunge: " + ("Good" if ok else "Bad: " + "; ".join(check['reasons']))
                # bottom if one knee <= LUNGE_FRONT_MAX
                knee_r = calculate_angle(joints[7][:2], joints[9][:2], joints[11][:2]) if 7 in joints and 9 in joints and 11 in joints else None
                knee_l = calculate_angle(joints[8][:2], joints[10][:2], joints[12][:2]) if 8 in joints and 10 in joints and 12 in joints else None
                front_bent = False
                if knee_r is not None and knee_l is not None:
                    front_bent = (knee_r <= LUNGE_FRONT_MAX and knee_r >= LUNGE_FRONT_MIN) or (knee_l <= LUNGE_FRONT_MAX and knee_l >= LUNGE_FRONT_MIN)
                is_down = front_bent
                counters['lunge'].update(is_down)

            else:
                feedback = "Unknown Exercise"

            # show text and rep counts
            color = (0,200,0) if ok else (0,0,255)
            cv2.putText(img, f"Exercise: {exercise.upper()}", (10,30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255,255,0), 2)
            cv2.putText(img, feedback, (10,60), cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)
            cv2.putText(img, f"Reps - Push:{counters['pushup'].count} Squat:{counters['squat'].count} Lunge:{counters['lunge'].count}",
                        (10,90), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (200,200,200), 2)

        else:
            cv2.putText(img, "No person detected", (10,30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0,255,255), 2)

        cv2.imshow("Exercise Classifier & Rep Counter - press q to quit", img)

cap.release()
cv2.destroyAllWindows()
